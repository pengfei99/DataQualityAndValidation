# dbt data validation

dbt provides native data validation supports on all its data related features such as **seeds, sources, and models**.
For more details about dbt features, please visit this [doc](https://github.com/pengfei99/DBTTutorial). In this tutorial,
I only focus on the data validation inside dbt.

Pros:
- easy to put in place/run
- can be integrated easily into each step of data transformation
- high level validation rule declaration, no need to write implementation logic

Cons:
- Only works with structure data (that can be read by dbt)
- limit built in validation rules(only 4)
- custom validation rules need to be written in sql.
- can only validate at column level, can't check table level

## 1. Built-in validation rules:
For now dbt only provides four possible tests:

- not_null: This test validates that there are no null values present in a column.
- unique: This test validates that there are no duplicate values present in a field.
- accepted_values: This test validates that all the values in a column are present in a supplied list of values. 
   If any values other than those provided in the list are present, then the test will fail.
- relationships: This test validates that all the records in a child table have a corresponding record in a parent table. This property is referred to as "referential integrity".

For more details about test, please visit the official [doc](https://docs.getdbt.com/reference/resource-properties/tests).

## 2. DBT project example with Tests

In this example project, we have two tables (e.g. customers, orders) that are generated by seeds (csv files), and two 
tables that are generated by models. To test them in dbt, we need to use a .yaml file. In this tutorial, I name this
file **schema.yaml**.


### 2.1 Test seeds

To test the validity of the two tables which are generated by seeds, we need to add validation rules to the columns
that we want to test. The description of tables and columns must be under keyword **seeds**.

Below yaml file is an example of how we check seeds.

 
1. For table customers, we test column customer_id is **unique, not null**.
2. For table orders, we test
    - column order_id is **unique, not_null**
    - column status **only contains value in list [ 'placed', 'shipped', 'completed', 'return_pending', 'returned' ]**
    - column customer_id has exactly the same value in column custom_id of table customers.
```yaml
version: 2
seeds:
  - name: customers
    description: Customer description, one record per customer # add a description to the table
    columns:
      - name: customer_id
        description: Primary key # add a description to column customer_id
        tests:
          - unique
          - not_null
      - name: first_name
        description: first name of user

  - name: orders
    description: Description of customer orders
    columns:
      - name: order_id
        tests:
          - unique
          - not_null
      - name: status
        tests:
          - accepted_values:
              values: [ 'placed', 'shipped', 'completed', 'return_pending', 'returned' ]
      - name: customer_id
        tests:
          - not_null
          - relationships:
              to: ref('stg_customers')
              field: customer_id

```

### 2.2 Test models

To test the validity of the two tables which are generated by models, we need to add validation rules to the columns
that we want to test. The description of tables and columns must be under keyword **models**.

1. For table stg_customers, we test column customer_id is **unique, not null**.
2. For table customer_order_history, we test
    - column customer_id is **unique, not_null**
    - column customer_id has exactly the same value in column custom_id of table customers.

```yaml
models:
  - name: stg_customers
    columns:
      - name: customer_id
        tests:
          - unique
          - not_null

  - name: customer_order_history
    description: >
      In this table, we describe the purchase history of all customers. We will show the date of the first and the last
      purchase of the customer. We will also show the total order of a customer
    columns:
      - name: customer_id
        description: the id of the customer
        tests:
          - unique
          - not_null
          - relationships:
              to: ref('customers')
              field: customer_id
  
```

### 2.3 Custom test

The table customer_order_history is created by **joining table stg_customers and orders**. Now, imagine we want to 
test after the join, the customer_order_history does not lose customer_id values. As we mentioned before, dbt only 
provides four built-in validation rule. As a result, we need to implement the test ourselves.

The custom test in dbt must **in format sql** and placed **under folder tests**

Below sql code is an example of custom test. The first left join will find all customer_is that exists in table
customer_order_history and not in table customers. The second left join will find all customer_is that exists in table
customers and not in table customer_order_history. Then we union the result of two join, if there is rows in the union,
it means something went wrong.

```sql
select *
from (
        select customer_oh.customer_id
        from {{ ref('customer_order_history') }} customer_oh
            left join {{ ref('customers') }} customer on customer_oh.customer_id = customer.customer_id
        where customer.customer_id is null
        UNION ALL
        select customer.customer_id
        from {{ ref('stg_customers') }} customer
            left join {{ ref('customer_order_history') }} customer_oh on customer_oh.customer_id = customer.customer_id
        where customer_oh.customer_id is null
    ) check
```

You can notice the implementation of a simple validation rule can be long, and not generic. Use it if you have no
other options.
